# Filmorate — сервис рекомендаций фильмов (групповой проект)


## Описание проекта

**Filmorate** — полнофункциональное Spring Boot‑приложение для управления фильмами и профилями пользователей с долговременным хранением данных. Ключевые возможности:
- регистрация и управление пользователями;
- работа с фильмами (включая жанры и рейтинги);
- система дружбы (односторонняя);
- лайки фильмов и рейтинг популярности;
- рекомендации на основе лайков;
- сохранение состояния между перезапусками через базу данных.

В этом проекте мною были решены три ключевые задачи:
1. **Реализация механизма удаления сущностей через REST API**  
2. **Создание функционала топа популярных фильмов**  
3. **Разработка системы поиска фильмов по подстроке**  

### 1-я задача

**Суть задачи**  
Требуется расширить функционал сервиса Filmorate, добавив возможность удаления пользователей и фильмов по идентификатору через REST API. Необходимо реализовать два endpoint‑а:
* `DELETE /users/{userId}` — для удаления пользователя;
* `DELETE /films/{filmId}` — для удаления фильма.

**Цели доработки:**
* обеспечить администраторов инструментом для очистки базы данных;
* дать пользователям возможность удалять свои аккаунты;
* поддерживать актуальность данных в системе;
* сохранить целостность базы данных при удалении сущностей.

**Выполненные работы**

1. **Проектирование API**
    * определены URL‑шаблоны и HTTP‑методы;
    * специфицированы параметры запросов (`userId`, `filmId`);
    * описаны коды ответов (``204 No Content`` при успехе, ``404 Not Found`` при отсутствии сущности).

2. **Реализация бизнес‑логики**
    * созданы контроллеры для обработки DELETE‑запросов;
    * разработаны сервисные методы для поиска и удаления сущностей;
    * реализована проверка существования объекта перед удалением.

3. **Обеспечение целостности данных**
    * настроено каскадное удаление связанных записей (лайки, рейтинги, дружеские связи);
    * обеспечено согласованное удаление всех зависимых данных.

4. **Обработка ошибок и безопасность**
    * добавлены проверки на корректность входных параметров;
    * реализован механизм возврата стандартизированных ошибок;

5. **Логирование действий**
    * внедрена запись в лог каждого факта удаления с указанием:
        * идентификатора объекта;
        * времени операции;

**Итоговый результат**  
В системе появились два новых endpoint‑а для удаления пользователей и фильмов. При вызове API:
* происходит поиск сущности по ID;
* удаляется основная запись и все связанные данные;
* возвращается соответствующий HTTP‑статус;
* событие фиксируется в логах.


### 2-я задача

**Суть задачи**  
Добавить в сервис Filmorate функционал получения топа *N* самых популярных фильмов, отсортированных по количеству полученных лайков. Результат должен поддерживаться фильтрацией по двум параметрам: жанру и году выпуска.

**Цель доработки**
* предоставить пользователям и администраторам инструмент для анализа популярности контента;
* дать возможность исследовать востребованные фильмы в разрезе жанров и временных периодов;
* расширить аналитические возможности сервиса.

**API‑endpoint**
```
GET /films/popular?count={limit}&genreId={genreId}&year={year}
```

**Параметры запроса**
* `count` (`{limit}`) — количество фильмов в топе (целое положительное число).
* `genreId` (`{genreId}`) — идентификатор жанра для фильтрации (целое число, может отсутствовать).
* `year` (`{year}`) — год выпуска фильмов для фильтрации (целое число, может отсутствовать).

**Поведение и логика работы**
1. Если параметр `genreId` не указан — учитываются фильмы всех жанров.
2. Если параметр `year` не указан — учитываются фильмы всех годов выпуска.
3. Фильмы сортируются по количеству лайков (по убыванию).
4. Возвращается не более `{limit}` записей.
5. В ответе включаются только опубликованные/активные фильмы (исключаются удалённые или скрытые).

**Коды ответов**
* `200 OK` — успешный запрос, возвращается список фильмов (может быть пустым, если нет совпадений).
* `400 Bad Request` — некорректные параметры (например, отрицательное `count`).
* `404 Not Found` — указанный `genreId` не существует (опционально, по решению команды).

**Выполненные работы**

1. **Проектирование API**
    * определён URL и метод запроса;
    * специфицированы параметры и их валидация;
    * описан формат ответа и возможные коды HTTP.

2. **Реализация бэкенда**
    * создан контроллер для обработки запроса `/films/popular`;
    * разработан сервисный метод для формирования топа фильмов;
    * реализована логика фильтрации по жанру и году;
    * добавлена сортировка по количеству лайков (DESC);
    * внедрена пагинация по параметру `count`.

3. **Валидация и обработка ошибок**
    * проверены корректность входных параметров (`count > 0`, существование `genreId`);
    * обработаны крайние случаи (пустой результат, несуществующие фильтры).

**Итоговый результат**  
В системе появился новый endpoint для получения топа фильмов по лайкам с гибкой фильтрацией. Пользователи и администраторы могут:
* задавать размер топа через параметр `count`;
* фильтровать результаты по жанру (`genreId`) и году выпуска (`year`);
* получать структурированный JSON‑ответ с основными данными о фильмах и количеством лайков.

Функционал повышает аналитические возможности сервиса и позволяет выявлять тренды в предпочтениях пользователей.

### Задача 3: реализация поиска фильмов по названию и режиссёру


**Суть задачи**  
Добавить в сервис Filmorate функционал поиска фильмов по подстроке в названии и/или имени режиссёра. Поиск должен быть гибким: при вводе фрагмента текста система возвращает все подходящие записи, где подстрока встречается в указанных полях.


**Цель доработки**
* обеспечить удобный поиск контента для пользователей;
* повысить юзабилити интерфейса за счёт нечёткого поиска (по подстроке);
* дать возможность фильтровать результаты по полям («название» / «режиссёр») или искать сразу по обоим.


**API‑endpoint**
```
GET /films/search
```

**Параметры запроса**
* `query` — поисковая подстрока (обязательный параметр).
* `by` — поле(я) для поиска, может принимать значения:
    * `title` — поиск только по названию фильма;
    * `director` — поиск только по имени режиссёра;
    * `title,director` — поиск одновременно по названию и режиссёру (через запятую, без пробелов).


**Примеры запросов**
1. Поиск по названию:
   ```
   GET /films/search?query=крад&by=title
   ```
2. Поиск по режиссёру:
   ```
   GET /films/search?query=спил&by=director
   ```
3. Поиск по обоим полям:
   ```
   GET /films/search?query=крад&by=title,director
   ```

**Поведение и логика работы**
1. Поиск выполняется **по подстроке** (не по полному совпадению).
2. Регистр символов не учитывается (поиск case‑insensitive).
3. Если `by` не указан, поиск ведётся по обоим полям (`title,director`).
4. Результаты сортируются **по популярности** (количеству лайков, убывание).
5. В ответ включаются только активные/опубликованные фильмы.
6. Максимальное количество результатов не ограничено (возвращаются все совпадения).


**Коды ответов**
* `200OK` — успешный запрос, возвращается список фильмов (может быть пустым, если совпадений нет).
* `400Bad Request` — отсутствовал параметр `query` или недопустимое значение `by` (например, не `title` / `director` / их комбинация).


**Выполненные работы**

1. **Проектирование API**
    * определён URL и метод запроса;
    * специфицированы параметры и их валидация;
    * описан формат ответа и возможные коды HTTP;

2. **Реализация бэкенда**
    * создан контроллер для обработки `/films/search`;
    * разработан сервисный метод с логикой поиска по подстроке;
    * реализована динамическая сборка запроса в зависимости от параметра `by`;
    * добавлена сортировка по `likeCount` (DESC).

3. **Валидация и обработка ошибок**
    * проверена обязательность параметра `query`;
    * валидированы допустимые значения `by`;
    * обработаны крайние случаи (пустая подстрока, несуществующие поля).


**Итоговый результат**  
В системе появился новый endpoint для поиска фильмов по подстроке в названии и/или имени режиссёра. Пользователи могут:
* вводить фрагмент текста в параметре `query`;
* указывать, где искать (`by=title`, `by=director`, `by=title,director`);
* получать список фильмов, отсортированный по популярности (лайкам);
* видеть основные данные о каждом фильме (id, название, режиссёр, год, количество лайков).

Функционал упрощает навигацию по каталогу и позволяет быстро находить контент даже при неполных входных данных.

## Схема базы данных

Актуальная структура данных представлена на диаграмме:  
![Диаграмма базы данных](diagram_db.png)